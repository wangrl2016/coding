package greedy;

/**
 * 贪心算法(Greedy Algorithm)
 *
 * 参考链接
 *
 * https://en.wikipedia.org/wiki/Greedy_algorithm
 *
 * 解释
 *
 * 贪心算法是一种在每一步选择中都采取在当前状态下最好或者最优的选择，从而希望导致结果是
 * 最好或者最优的算法。比如在旅行推销员的问题中，如果旅行员每次都是选择最近的城市，
 * 那么这就是一种贪心算法。
 *
 * 贪心算法在有最优最结构的问题中尤为有效，最优子结构的意思是局部最优解能决定全局最优解。
 *
 * 贪心算法与动态规划的不同在于它对于每个子问题的解决方案都作出选择，不能回退。动态规划
 * 则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
 *
 * 对于大部分问题，贪心算法通常都找不出最优解，因为贪心算法容易过早做决定，因而没法达到
 * 最佳解。
 *
 * 霍夫曼编码(Huffman Coding)
 *
 * 参考链接
 *
 * https://en.wikipedia.org/wiki/Huffman_coding
 *
 * 霍夫曼编码使用变长编码表对源符号(如文件的一个字母)进行编码，其中变长编码表是通过一种评估
 * 来源符号出现的几率的方法得到的，出现几率高的字母使用较短的编码，反之出现几率低的则使用
 * 较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。
 *
 * 例如在英文中，e的出现几率最高，而z的出现几率最低。当使用霍夫曼编码对一篇英文进行压缩时，
 * e极有可能使用一个bit来表示，而z则可能会花去25个bit。用普通的表示方法时，每个英文字符
 * 均占用一个byte，即8个bit，二者相比，e使用了一般编码的1/8长度，z则使用了3倍多。倘若
 * 我们能实现对于英文中的各个字母出现概率进行较准确的估算，那么久可以大幅度提高无损压缩
 * 的比例。
 *
 * 霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树，所谓树的带权路径长度，就是树中所有
 * 的叶节点的权值乘上其到根节点的路径长度(若根节点位0层，叶节点到根节点的路径长度为叶节点
 * 的层数)。
 *
 * 树的路径长度 WPL = W1 * L1 + W2 * L2 + ... + Wn * Ln
 *
 * N个权值Wi构成一个有N个叶节点的二叉树，相应的叶节点的路径长度为Li，可以证明霍夫曼树的WPL是最小的。
 *
 * 问题定义和解法
 *
 * 输入集合S = {s1, s2, ..., sn}，其S集合的大小为n。
 * 权重集合W = {w1, w2, ..., wn}，其W集合不为负数且wi = weight(si), 1 <= i <= n。
 * 输出一组编码C(S,W)= {c1, c2, ..., cn}，其C集合是一组二进制编码且ci为si相对应的编码。
 */

public class HuffmanCoding {
    

}
